## **📕 Ch15. JUnit 들여다보기**

저명한 자바 테스트 프레임워크인 JUnit의 코드를 점진적으로 리팩토링하는 과정을 상세히 보여준다. 예제는 자바지만, 클린 코드 관점에서 언어의 차이는 본질이 아니다. 원칙은 프론트엔드에도 적용된다.

### 1. 복잡한 조건문은 의미 있는 함수로 숨기기
세 항이 넘어가는 복잡한 조건문을 별도의 함수로 캡슐화하고, 함수명을 주석처럼 사용할 수 있다.

```js
// Before: 무엇을, 왜 렌더링하는지 한눈에 파악하기 어렵다.
return (
  <div>
    {user.isLoggedIn && !isLoading && user.hasPermission('editor') && data.isPublished && (
      <EditorComponent />
    )}
  </div>
);

// After: 'isEditable'이라는 이름만으로도 의도가 명확해진다.
const isEditable = () => {
  return user.isLoggedIn && !isLoading && user.hasPermission('editor') && data.isPublished;
};

return (
  <div>
    {isEditable() && <EditorComponent />}
  </div>
);
```
isEditable이라는 함수명 자체가 주석의 역할을 수행하며, 복잡한 비즈니스 로직을 JSX의 렌더링 영역으로부터 깔끔하게 분리해준다. 이는 단순히 코드를 짧게 만드는 것을 넘어, 컴포넌트의 핵심 역할인 '무엇을 보여줄 것인가'에만 집중하도록 돕는다. 마치 복잡한 상태 로직을 커스텀 훅(Custom Hook)으로 분리하여 재사용성과 가독성을 높이는 것과 같은 맥락이다.

### 2. 부정문보다는 긍정문이 더 이해하기 수월하다

프론트엔드에서는 isLoading, isError, isValid 같은 플래그를 자주 쓴다. 이때 !isNotValid보다 isValid, !isNotLoading보다 isLoading이 인지 부하가 훨씬 낮다. <br />
예를 들어 if (!isLoading && !isError)는 두 번 부정해석을 거쳐야 하지만, if (isSuccess)는 즉시 이해된다. 상태를 설계할 때부터 긍정형을 기본값으로 두면 버그가 줄고 협업이 수월해진다.


### 3. 시간적인 결합은 외부로 노출하기
책에서 언급된 '시간적인 결합'은 프론트엔드에서도 중요하게 고려해야한다. 데이터 fetching, 렌더링, 애니메이션, 사용자 입력 등 모든 것이 비동기적으로 얽혀 순서가 매우 중요하기 때문이다.

<br />
이때는 props로 결합을 명시할 수도 있고, 래퍼 컴포넌트를 만들어 그 로직의 순서를 명시할 수도 있다.


### 마무리
> "세상에 개선이 불필요한 모듈은 없다. 코드를 처음보다 조금 더 깨끗하게 만드는 책임은 우리 모두에게 있다."

JUnit이라는 거대한 오픈소스 프로젝트의 일부 코드를 리팩토링하는 과정을 천천히 따라가니 나도 오픈소스에 기여하는 기분이라 재밌었다.
<br />
프론트엔드 생태계는 빠르게 변하지만, 가독성, 명확성, 예측 가능성이라는 코드의 본질적인 가치는 변하지 않는다. 책에서 보여준 리팩토링 과정을 따라가며 느꼈던 즐거움처럼, 앞으로 마주할 레거시 코드나 혹은 내가 막 작성한 코드라도 조금 더 나은 상태로 만들어 동료에게 전달해야겠다. 그리고 나도 언젠가 오픈소스에 기여하며 더 넓은 세상의 코드에 긍정적인 영향을 미치고 싶다.







