**📕 Ch13. 동시성**

동시성과 깔끔한 코드는 양립하기 어렵다.
[장점]
1. 동시성은 결합을 없애는 전략이다. 동시성을 활용하면 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 보인다. 따라서 시스템을 이해하기 쉽고 문제를 분리하기 쉽다.
2. 응답 시간과 작업 처리량을 개선할 수 있다.

[고려해야할 점]
1. 동시성이 항상 성능을 높여주는 것은 아니다. 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다. 오히려 다소 부하를 유발한다. 
2. 동시성은 복잡하다.
3. 동시성 버그는 재현하기 어렵다.
4. 근본적인 설계 전략을 재고해야 한다.


필자는 자바 관점에서 동시성을 설명해서 이해가 어려웠지만, 이를 자바스크립트에서도 적용해서 생각해보았다.
<br>자바스크립트는 싱글 스레드이지만 브라우저의 Web API와 이벤트 루프 덕분에 비동기 처리가 가능하다.
<br>이를 이용하여 동시성을 활용할 수 있지만, 주의할 점이 있다.
<br>
예를 들어 Promise.all을 사용하면 여러 비동기 작업을 병렬로 실행할 수 있다.<br>
하지만 요청 간에 종속성이 있을 경우, 병렬 처리는 오히려 요청 낭비나 UX 저하를 초래할 수 있다.<br>
<br>
또한 비동기 요청은 응답 순서를 보장하지 않기 때문에 race condition이 발생하기 쉽다. <br>
실제로 검색 자동완성 기능을 구현할 때, 사용자가 검색어를 빠르게 바꿨을 경우
이전 요청이 나중에 응답되면 UI에 오래된 결과가 렌더링되는 문제가 발생할 수 있다.
<br>AbortController를 써서 이전 요청을 취소하고 해결할 수 있다고 한다. 왜 나느 지금까지 이런 흔한 동시성 문제를 겪지 않았는지 생각해보았는데, 항상 tanstack-query를 사용하기 때문이었다.<br>
tanstackquery는 내부적으로 AbortController를 이용해 이전 요청을 자동으로 취소하고, 동일한 쿼리 키로 중복 요청을 막아준다.
또한 isFetching, staleTime, retry 등 다양한 상태와 타이밍 제어도 내장되어 있어,
동시성을 직접 제어하지 않아도 안정적이고 예측 가능한 흐름을 유지할 수 있다.<br>
그동안은 이 기능들을 그저 프레임워크가 해주는 기본 동작처럼 당연하게 사용했기에
그 중요성을 제대로 인식하지 못하고 있었다.

프론트엔드에서 동시성을 다룬다는 건 성능을 높이는 기술적 트릭보다도,
사용자 경험을 해치지 않으면서 예측 가능한 흐름을 만들어가는 것이 중요하다는 것을 느꼈다.<br>
클린코드에서 말한 동시성의 복잡성과 위험성은 프론트엔드에도 적용된다.<br>
그래서 복잡함을 잘 추상화해주는 도구나 패턴을 적극 활용하고,
설계 자체를 동시성에 맞게 정돈하는 것이 진정한 클린 코드에 가까운 길이라는 걸 느꼈다.
