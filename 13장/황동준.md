## 13장 동시성

<226p>

동시성은 결합을 없애는 전략이다. 즉 무엇과 언제를 분리하는 전략이다.
~ 무엇과 언제를 분리하면 애클리케이션 구조와 효율이 극적으로 나아진다.

<230p>

동시성 방어 원칙

단일 책임 원칙<br/>
SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다. 동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하다. 즉, 동시성 관련 코드는 다른 코드와 분리해야 한다는 뜻이다. 그런데 불행히도 동시성과 간련이 없는 코드에 동시성을 곧바로 구현하는 사례가 너무도 흔하다. 동시성을 구현할 때는 다음 몇 가지를 고려한다.

- 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
- 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르면 훨씬 어렵다.
- 잘못 구현한 동시설 코드는 별의별 방식으로 실패한다. 주변에 있는 다른 코드가 발목을 잡지 않더라도 동시성 하나만으로도 충분히 어렵다.

따름 정리: 자료 범위를 제한하라
앞서 봤듯이, 객체 하나를 공유한 후. 동일 필드를 수정하던 두. 스레드 가 서로 간섭하므로 예상치 못한 결과를 내놓는다. 이런 문제를 해결하는 방안으로 공유 객체를 사용하는 코드 내 임계영역을 synchroniaed 키워드로 보호하라고 권장한다.

<243p>

다중 스레드 코드는 올바로 구현하기 어렵다. 간단했던 코드가 여러 스레드와 공유 자료를 추가하면서 악몽으로 변한다. 다중 스레드 코드를 작성한다면 각별히 깨끗하게 코드를 짜야 한다.

무엇보다 먼저, SRP를 준수한다. POJO를 사용해 스레드를 아는 코드와 스레드를 모르는 코드를 분리한다. 그레드 코드를 테스트할 때는 전적으로 스레드만 테스트한다. 즉, 그레드 코드는 최대한 집약되고 작아야 한다는 의미다.

**사용하는 라이브러리와 기본 알고리즘을 이해한다.** 특정 라이브러리 기능이 기본 알고리즘과 유사한 어떤 문제를 어떻게 해결하는지 파악한다.<br/>
-> 매우 중요한 소양이라고 생각합니다.

어떻게든 문제는 생긴다. 초반에 드러나지 않는 문제는 일회성으로 치부해 무시하기 십상이다. 소위 일회성 문제는 대개 시스템에 부하가 걸리 때나 아니면 뜬금없이 발생한다. 그러므로 스레드 코드는 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트해야 한다. **테스트 용이성은 TDD 3대 규칙을 따르면 자연히 얻어진다.**
