### 동시성이 필요한 이유?

- 동시성은 결합(coupling)을 없애는 전략이다
- 즉, 무엇과 언제를 분리하는 전략이다
- 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접하다
- 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다
- 서블릿을 예로 보면, 웹 요청이 들어올 때마다 웹 서버는 비동기식으로 서블릿을 실행한다
- 원칙적으로 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아간다

<br>

- 구조적 개선만을 위해 동시성을 채택하는 건 아니다
- 응답 시간과 작업 처리량(throughput) 개선이라는 요구사항으로 인해 직접적인 동시성 구현이 불가피하다
- 많은 사용자를 동시에 처리하면 시스템 응답 시간을 높일 수 있다

<br>

**미신과 오해**

- 동시성은 항상 성능을 높여준다
    - → 동시성은 때로 성능을 높여준다
    - 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다

---

### 💡 상황: 외부 요청을 기다려야 하는 작업 (I/O 대기 중심)

```java
public class EmailSender {
    public void send() {
        // SMTP 서버에 요청 → 대기 2초
        Thread.sleep(2000); // 대기 시간
    }
}
```

- 만약 **100명이 동시에 이메일 보내야 하는데**,
- 한 쓰레드로 처리하면 100 × 2초 = **200초**
- 하지만 **10개 쓰레드로 병렬 처리**하면 20초 안에 끝남

✅ **결과**: I/O 대기가 많을 때 동시성 적용 → CPU 놀지 않음 → **성능 향상**

### 💡 상황: 계산량 많은 CPU 작업 + 공유 자원 접근

```java
public class Calculator {
    private int total = 0;

    public synchronized void add() {
        for (int i = 0; i < 1_000_000; i++) {
            total++;
        }
    }
}

```

- 여러 스레드가 동시에 `add()`를 호출하면?
    - **synchronized** 때문에 **락 경쟁 발생**
    - CPU는 계산보다 락 기다리느라 낭비
- 결과적으로 **단일 스레드보다 느려질 수도 있음**

❌ **결과**: 락 경합, 컨텍스트 스위칭 비용 → **성능 하락**

---

- 동시성을 구현해도 설계는 변하지 않는다
    - 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다
    - 실제로 컨테이너가 어떻게 동작하는지
    - 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지를 알아야만 한다

<br>

**타당한 생각**

- 동시성은 다소 부하를 유발한다
- 동시성은 복잡하다
- 일반적으로 동시성 버그는 재현하기 어렵다
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다

<br>

### 난관

<img width="592" height="507" alt="image" src="https://github.com/user-attachments/assets/5c7c31b2-8d3b-4a89-b116-073e63d5ea8f" />

- 두 스레드가 같은 변수를 동시에 참조하면 세 번째와 같이 놀라운 결과가 발생한다
- 두 스레드가 자바 코드 한 줄을 거쳐가는 경로는 수없이 많은데, 그 중에서 일부 경로가 잘못된 결과를 내놓기 때문이다
- 정확히는 JIT 컴파일러가 바이트 코드를 처리하는 방식과 자바 메모리 모델이 원자로 간주하는 최소 단위를 알아야 한다
- 물론 대다수 경로는 올바른 결과를 내놓지만, 잘못된 결과를 내놓는 일부 경로가 있다

<br>

### 동시성 방어 원칙

1. **단일 책임 원칙**
- 동시성 관련 코드는 다른 코드와 분리해야 한다

<img width="634" height="197" alt="image" src="https://github.com/user-attachments/assets/ca85e8bb-d6e8-4d11-b56b-89dc2cab7ca1" />

<br>

2. **따름 정리 : 자료 범위를 제한하라**
- 공유 객체를 사용하는 코드 내 임계영역(critical section)을 synchronized 키워드로 보호하라고 권장한다
- 공유 자료를 수정하는 위치가 많을수록 다음 가능성도 커진다
- 보호할 임계영역을 빼먹는다
- 모든 임계영역을 올바르게 보호했는지 확인하느라 똑같은 노력과 수고를 반복한다

→ 권장사항 : 자료를 캡슐화하라. 공유 자료를 최대한 줄여라

<br>

3. **따름 정리 : 자료 사본을 사용하라**
- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다
- 객체를 복사해 읽기 전용으로 사용하는 방법과
- 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법도 가능하다
- 사본으로 동기화를 피할 수 있다면 내부 잠금을 없애 절약한 수행 시간이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다

<br>

4. **따름 정리 : 스레드는 가능한 독립적으로 구현하라**
- 다른 스레드와 자료를 공유하지 않는 스레드를 구현하자
- 각 스레드는 클라이언트 요청 하나를 처리하며, 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다

→ 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라

<br>

### 라이브러리를 이해하라

**스레드 환경에 안전한 컬렉션**

- ConcurrentHashMap은 거의 모든 상황에서 HashMap보다 빠르다
- 동시 읽기/쓰기를 지원하며, 자주 사용하는 복합 연산을 다중 스레드 상에서 안전하게 만든 메서드로 제공한다

→ 언어가 제공하는 클래스를 검토하라. 자바에서는 java.util.concurrent, concurrent.atomic, concurrent.locks를 익혀라

<br>

### 실행 모델을 이해하라

**생산자 - 소비자**

- 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정된 자원이다
- 대기열을 올바로 사용하고자 생산자 스레드와 소비자 스레드는 서로에게 시그널을 보낸다
- 잘못하면 동시에 시그널을 보낼 수도 있다

<br>

**읽기 - 쓰기**

- 처리율을 강조하면 기아(starvation) 현상이 생기거나 오래된 정보가 쌓인다
- 대게는 쓰기 쓰레드가 버퍼를 오랫동안 점유하는 바람에 여러 읽기 스레드가 버퍼를 기다리느라 처리율이 떨어진다
- 양쪽 균형을 잡으면서 동시 갱신 문제를 피하는 해법이 필요하다

<br>

**식사하는 철학자들**

- 철학자를 스레드로 포크를 자원으로 바꿔 생각해보자
- 주의해서 설계하지 않으면 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 겪는다

→ 위에서 설명한 기본 알고리즘과 각 해법을 이해하라

<br>

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

- 동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다

→ 공유 객체 하나에는 메서드 하나만 사용하라

<br>

1. 클라이언트에서 잠금 - 첫번째 메서드를 호출하기전 클라이언트에서 잠근다. 끝날때까지
2. 서버에서 잠금 - 서버를 잠그고 모든 메서드 호출 후 해제하는 메서드 구현
3. 연결 서버 - 잠금을 수행하는 중간 단계를 생성한다

<br>

### 동기화하는 부분을 작게 만들어라

- 락은 스레드를 지연시키고 부하를 가중시킨다
- 필요 이상으로 임계영역 크기를 키우면 스레드 간에 경쟁이 늘어나고 프로그램 성능이 떨어진다

<br>

### 올바른 종료 코드는 구현하기 어렵다

- 깔끔하게 종료하는 코드는 올바로 구현하기 어렵다
- 흔히 발생하는 문제가 데드락으로, 스레드가 절대 오지 않을 시그널을 기다린다
- 자식 스레드가 생산자/소비자 관계라면, 생산자에서 메시지를 기다리는 소비자 스레드는 차단(blocked) 상태에 있으므로 종료하라는 시그널을 못 받는다

---

✅ 문제 발생

```java
BlockingQueue<String> queue = new LinkedBlockingQueue<>();

// 소비자 스레드
Thread consumer = new Thread(() -> {
    try {
        while (true) {
            String msg = queue.take(); // 🚨 여기서 블로킹됨
            if (msg.equals("STOP")) break; // 종료 신호
            System.out.println("Consumed: " + msg);
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
});

// 생산자 스레드
Thread producer = new Thread(() -> {
    // 아무것도 넣지 않음
});

consumer.start();
producer.start();

```

위 코드에서 `queue.take()`는 큐가 비어 있으면 **무한 대기(block)** 한다

`"STOP"` 같은 종료 신호가 큐에 **들어오지 않으면**,

**consumer 스레드는 끝나지 못하고 영원히 대기 상태에 빠짐.**

---

→ 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라. 생각보다 오래 걸린다. 생각보다 어려우므로 이미 나온 알고리즘을 검토하라

<br>

### 스레드 코드 테스트하기

- 문제를 노출하는 테스트 케이스를 작성하라
- 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라
- 테스트가 실패하면 원인을 추적하라
- 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 절대로 안 된다

아래 지침들로 여러가지를 고려해보자

<br>

1. 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라
- 다중 스레드 코드는 때때로 ‘말이 안 되는’ 오류를 일으킨다
- 스레드 코드에 잡입한 버그는 수천, 아니 수백만 번에 한 번씩 드러나기도 한다

2. 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
- 스레드 환경 밖에서 코드가 제대로 도는지 반드시 확인한다
- 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라
- 먼저 스레드 환경 밖에서 코드를 올바로 돌려라

3. 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
- 스레드 코드를 실제 환경이나 테스트 환경에서 둘러본다
- 빨리, 천천히, 다양한 속도로 돌려본다

4. 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
- 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민한다

5. 프로세서 수보다 많은 스레드를 돌려보라
6. 다른 플랫폼에서 돌려보라
7. 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라
- 스레드 버그가 산발적이고 우발적이고 재현이 어려운 이유는 코드가 실행되는 수천 가지 경로 중에 아주 소수만 실패하기 때문이다
- Object.wait(), Object.sleep(), Object.yield(), Object.priority 등과 같은 메서드를 추가해 코드를 다양한 순서로 실행한다

<br>

### 보조 코드 추가

**직접 구현하기**

- 보조 코드를 삽입할 적정 위치를 직접 찾아야 한다
- 어떤 함수를 어디서 호출해야 적당할까
- 배포 환경에 보조 코드를 그대로 남겨두면 프로그램 성능이 떨어진다
- 무작위적이다. 오류가 드러날지도 모르고 드러나지 않을지도 모른다
- 배포 환경이 아니라 테스트 환경에서 보조 코드를 실행할 방법이 필요하다

<br>

**자동화**

- AOF, CGLIB, ASM 등과 같은 도구를 사용한다

<img width="632" height="510" alt="image" src="https://github.com/user-attachments/assets/ce3f20c8-7433-4d4e-a7d6-9d7f1a30ff81" />

- jiggle은 무작위로 sleep나 yield를 호출한다
- 코드를 흔드는 이유는 스레드를 매번 다른 순서로 실행하기 위해서다
- 이는 오류가 드러날 확률을 크게 높여준다

<br>

### 결론

- 다중 스레드 코드를 작성한다면 각별히 깨끗하게 코드를 짜야 한다
- POJO를 사용해 스레드를 아는 코드와 스레드를 모르는 코드를 분리한다
- 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해한다
- 특정 라이브러리 기능이 기본 알고리즘과 유사한 어떤 문제를 어떻게 해결하는지 파악한다
- 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해한다
- 스레드 코드는 출시하기 전까지 최대한 오랫동안 돌려봐야 한다
