# 10장 클래스
- 코드 표현력과 그 코드로 이루어진 함수에 아무리 신경 쓸지라도 더 차원 높은 단계까지 신경 쓰지 않으면 깨끗한 코드를 얻기는 어렵다

### 클래스 쳬계

- 가장 먼저 변수 목록이 나온다
    1. static, public 상수가 있다면 맨 처음에 나온다
    2. 다음으로 private 변수가 나오며
    3. 이이서 비공개 인스턴스 변수가 나온다
    4. 변수 목록 다음에는 공개 함수가 나온다
    5. 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다

**캡슐화**

- 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없다
- 때로는 protected로 선언해 테스트 코드에 접근을 허용하기도 한다
- 같은 패키지 안에서 테스트 코드가 함수를 호출하거나 변수를 사용해야 한다면 그 함수나 변수를 protected로 선언하거나 패키지 전체로 공개한다
- 하지만 그 전에 비공개 상태를 유지할 온갖 방법을 강구해야 한다

### 클래스는 작아야 한다

- 클래스는 작아야 한다. 더 작아야 한다. 작아야 한다.
- 함수는 물리적인 행 수로 크기를 측정했지만 클래스는 클래스가 맡은 책임을 센다
- 클래스 이름은 해당 클래스 책임을 기술해야 한다
    - 간결한 이름이 떠오르지 않는다면 클래스 크기가 너무 커서 그렇다
    - 이름이 모호하다면 클래스 책임이 너무 많아서다
    - 이름에 Processor, Manager, Super등과 같이 모호한 단어가 있다면 여러 책임을 떠안겼다는 증거다
    - 클래스 설명은 만일(if), 그리고(and), -(하)며(or), 하지만(but)을 사용하지 않고서 25단어 내외로 가능해야 한다

**단일 책임 원칙(SRP)**

- 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다
- 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다

 <img width="600" height="300" alt="image (3)" src="https://github.com/user-attachments/assets/6c0d7b19-028f-4e5c-b6e1-98115ae7e9b7" />

- SRP는 중요한 개념이자만 클래스 설계자가 가장 무시하는 규칙 중 하나다
- 대다수는 ‘깨끗하고 체계적인 소프트웨어’보다 ‘돌아가는 소프트웨어’에 초점을 맞춘다
- 만능 클래스를 단일 책임 클래스 여럿으로 분리하는 대신 다음 문제로 넘어가버린다
- 하지만 복잡성을 다루려면 체계적인 정리가 필수다
- 큼직한 시스템은 당장 알 필요가 없는 사실까지 들이밀며 독자를 방해한다
- 큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다

**응집도**

- 클래스는 인스턴스 변수 수가 작아야 한다
- 일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다
- 하지만 이는 꼭 바람직한 것은 아니다.
- 응집도가 높다는 말은 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미다
- 인스턴스 변수가 아주 많아지는 경우, 십중팔수 새로운 클래스로 쪼개야 한다는 신호다

**응집도를 유지하면 작은 클래스 여럿이 나온다**

- 빼내려는 코드가 큰 함수에 정의된 변수 넷을 사용한다.
- 그렇다면 변수 4개를 새 함수에 인수로 넘겨야 옳을까?(아니다)
- 4개의 변수를 클래스 인스턴스 변수로 승격한다면 새 함수는 인수가 필요없다
- 그만큼 함수를 쪼개기 쉬워진다
- 몇몇 함수가 몇몇 변수만 사용한다면 독자적인 클래스로 분리하자
- 클래스가 응집력을 잃는다면 쪼개라!

**리팩터링하면 프로그램이 길어진다?**

- 이유는 여러 가지다
1. 리팩터링한 프로그램은 좀 더 길고 서술적인 변수 이름을 사용한다
2. 코드에 주석을 추가하는 수단으로 함수 선언과 클래스 선언을 활용한다
3. 가독성을 높이고자 공백을 추가하고 형식을 맞추었다

### 변경하기 쉬운 클래스

- 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다
- 어떤 변경이든 클래스에 손대면 다른 코드를 망가뜨릴 잠정적인 위험이 존재한다

<img width="600" height="300" alt="image (4)" src="https://github.com/user-attachments/assets/3cbc5e8d-76c7-415c-a3d4-a5bcc2e73212" />

위와 같은 경우

1. 새로운 SQL문을 지원하려면 반드시 Sql 클래스에 손대야 한다
2. 기존 SQL문 하나를 수정할 때도 반드시 Sql 클래스에 손대야 한다
3. selectWithCriteria 라는 비공개 메서드가 있는데, 이 메서드는 select 문을 처리할 때만 사용한다

<img width="600" height="300" alt="image (5)" src="https://github.com/user-attachments/assets/f85d878e-8e40-407a-bab1-62e7221bf0ec" />

위처럼 클래스를 분리하면,

1. 코드는 순식간에 이해되며
2. 함수 하나를 수정했다고 다른 함수가 망가질 위험도 사실상 사라졌다
3. 테스트 관점에서 모든 논리를 증명하기도 쉬워졌다
4. 또한 SRP와 OCP를 지원한다

→ 이처럼 새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조가 바람직하다

### 변경으로부터 격리

- 상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀌면 위험하다
- 또한 상세한 구현에 의존하는 코드는 테스트가 어렵다
- 5분마다 값이 달라지는 API로 테스트 코드를 짜기란 쉽지 않다

<img width="600" height="300" alt="image (6)" src="https://github.com/user-attachments/assets/3ea9508c-8131-48bd-ad96-1f11364b9731" />

- 위와 같은 테스트가 가능할 정도로 시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다
- 이렇게 결합도를 줄이면 자연스럽게 DIP 를 따르는 클래스가 나온다
- DIP는 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다
