**📕 Ch10. 클래스**

> 캡슐화 : 변수와 유틸리티 함수는 protected로 선언하거나 패키지 전체로 공개해 테스트 코드에 접근을 허용하기도 하지만, 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.

> 클래스 이름은 해당 클래스 책임을 기술해야 한다. 클래스 이름이 모호하다면 필경 클래스 책임이 너무 많아서다.
클래스 이름에 Processor, Manager, Super 등과 같이 모호한 단어가 있다면 클래스에다 여러 책임을 떠안겼다는 증거다.

> 클래스 설명은 만일, 그리고, 또는, 하지만 을 사용하지 않고서 25단어 내외로 가능해야 한다.

> SRP 단일 책임 원칙 : 클래스나 모듈을 변경할 이유는 단 하나 뿐이어야 한다.

> '돌아가는 소프트웨어'보다 '깨끗하고 체계적인 소프트웨어'

> 함수를 작게, 매개변수 목록을 짧게 전략을 따르다 보면 몇몇 메서드 만이 사용하는 인스턴스 변수가 아주 많아진다. 이는 새로운 클래스로 쪼개야 한다는 신호다.

> OCP: 확장에 개방적이고 수정에 폐쇄적이어야한다. 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지는 않는다.

> DIP: 클래스는 상세한 구현이 아니라 추상화에 의존해야 한다.

프론트엔드는 클래스보다 함수형 컴포넌트를 더 자주 쓰긴 하지만, 결국 중요한 건 컴포넌트가 하나의 명확한 책임만 가지는가 라는 점이다.

책에서는 클래스 이름에 Manager, Processor, Super 같은 단어가 붙어 있다면 여러 책임을 떠안았다는 신호라고 했다. 이건 프론트엔드 컴포넌트에도 똑같이 적용된다.

예전에 CalendarManager.tsx 같은 컴포넌트를 만든 적이 있다. 처음엔 잘 만든 줄 알았지만, 나중엔 이 컴포넌트가 캘린더 데이터를 불러오고, 헤더를 그리고, 일정 리스트를 렌더링하고..
너무 많은 일을 하고 있다는 걸 깨달았다. 점점 유지보수가 어려워졌고, 코드도 정신없어졌다.

지금은 CalendarHeader, ScheduleList 처럼 기능별로 컴포넌트를 나누고, 이름도 그에 맞게 짓는다.
이름이 애매하면, 역할도 애매하다는 걸 실감했다.



📦 SRP

컴포넌트를 쪼개다 보면 꼭 한 번쯤 고민하게 되는 문제다.
한때 아토믹 디자인 패턴을 적용해본 적이 있었는데, 오히려 컴포넌트가 너무 잘게 쪼개져서 폴더 구조가 복잡해지고, UI의 전체 구조를 파악하기 더 어려워졌던 경험이 있다.
그래서 지금은 무조건 작게 나누기보다,
	•	역할이 명확한지
	•	재사용 가능성은 있는지
	•	서로 의존성이 강한지
	•	추후 확장 가능성은 어떤지

같은 기준들을 바탕으로 유연하게 쪼개려 하고 있다.
“작게 나눈다”보다 “명확하게 나눈다”가 더 중요한 것 같다.

🔁 OCP

클린코드에서 말하는 OCP는 새로운 기능 추가 시 기존 코드를 변경하지 않고 확장으로 해결해야 한다는 원칙이다.
프론트엔드에서 이걸 적용해본 사례로는 합성 컴포넌트가 떠오른다.
새로운 요구사항이 생겨도 기존 컴포넌트는 그대로 두고, 필요한 요소만 추가해서 확장할 수 있는 강력한 장점이 있다.
다만, 합성 컴포넌트는 설계가 잘못되면 코드량이 많아지고 구조가 복잡해질 수 있는 단점도 있다. 그래서 단순한 UI에는 오히려 지나치게 무거울 수 있다는 점도 느꼈다.

클린 코드에서 말하는 OCP, SRP 같은 원칙을 프론트엔드 컴포넌트 설계에 100% 그대로 적용하는 건 쉽지 않다.
하지만 그 사이에서 균형을 잡아가는 게 중요한 것 같다.
	•	역할과 책임을 명확히 나누되
	•	쪼개는 기준은 유연하게
	•	확장은 열되, 변경은 최소화하고
	•	복잡도를 피하면서도 재사용성을 고려한다

이상적인 설계원칙,,,,, 팀원들이 함께 유지보수해야 하니까.
그래서 돌아가는 코드보다, 구조가 명확한 코드를 지향해야겠다고 느꼈다.
