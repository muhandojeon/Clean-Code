**📕 Ch11. 시스템**

> 큰 그림을 이해하지 못할지라도, 개인이 관리하는 구성요소는 효율적으로 돌아간다.

큰 그림을 이해하지 못하더라도, 개인이 관리하는 구성요소는 효율적으로 만들 수 있고 그것이 모여 큰 그림을 이룬다는 것이 인상깊다. 프론트엔드 개발자로서 시스템 전체를 다 알지 못하더라도, 내가 만든 컴포넌트/로직이 잘 분리되어 있고 효율적으로 작동한다면 그것드이 모여 큰 시스템을 이룬다.
결국 모듈성과 확장성의 핵심인 것 같다.
<br>
<br>
> 설정 논리와 일반 실행 논리와 분리해야 모듈성이 높아진다.
> 
> 실행 시점에서 객체를 생성해야 할 때는 추상 팩토리 패턴을 사용한다. 생성 시점은 애플리케이션이 결정하지만 생성하는 로직은 애플리케이션이 모르게 한다.

프론트엔드에서도 API 클라이언트를 설정하거나 상태관리 라이브러리를 초기화할때 설정 파일을 별도로 분리하여 설정 논리를 별도로 분리해둔다.
<br><br>
> 의존성 주입 : 사용과 제작을 분리하는 강력한 메커니즘.? 제어 역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다. 새로운 객체는 넘겨받은 책임만 맡으므로 SRP를 지키게 된다.
클래스는 의존성을 해결하는 게 아니라 의존성을 주입한다.

자바 기준으로 설명되어 있어 예시를 이해하기에 어려웠지만, 의존성 주입은 프론트엔드에서 hook과 비슷한 것 같다.
컴포넌트 내부에서 직접 fetch 로직을 수행하는 것이 아니라 useUser()와 같은 커스텀훅으로 분리하면, 컴포넌트는 데이터를 사용하고, 훅은 데이터를 가져오는 책임을 지게 된다.
<br><br>
> 확장 : 소프트웨어 시스템은 수명이 짧다는 본질로 인해 아키텍처의 점진적인 발전이 가능하다. 

이 말에 공감이 됐던 게, 최근에 개인 사이드 프로젝트를 시작하면서
빠르게 프로토타입을 만들기 위해 Next.js + Supabase로 시작했다.
나중에 API 서버를 따로 만들고 붙이기로 계획되어 있어 구조를 대거 변경해야하지만,
비즈니스 로직을 분리해두면 나중에 서버 로직을 붙이기 어렵지 않을 거라는 판단이 있었다.

물론… 이 판단이 아직 “겪기 전 패기”일 수도 있지만,,,
클린코드에서 말하는 유연한 시스템 구성의 마인드를 참고하면서,
일단은 작게, 단순하게, 확장 가능하게 만드는 걸 목표로 하고 있다.

<br><br>
> AOP(관점 지향 프로그래밍) ? 비즈니스 로직과 상관없는 공통 기능(관심사)을 분리해서 코드 중복을 줄이고, 가독성을 높이자는 철학

ErrorBoundary, Suspense, Axios 인터셉터와 같이 공통 관심사를 한 곳에서 관리하는 것을 지향한다. 
<br><br>
> POJO ? 프레임워크나 특정 기술에 의존하지 않는, 순수한 자바 객체

